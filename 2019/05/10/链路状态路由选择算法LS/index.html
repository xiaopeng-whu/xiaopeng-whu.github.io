<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="链路状态路由选择算法LS"><meta name="keywords" content="路由算法"><meta name="author" content="Zepeng Wang"><meta name="copyright" content="Zepeng Wang"><title>链路状态路由选择算法LS | 王小鹏's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '3.8.0'
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Zepeng Wang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">王小鹏's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">链路状态路由选择算法LS</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/计算机网络/">计算机网络</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><hr>
<p>一个主机通常与一台路由器相连接，该路由器即为主机的默认路由器。<br>源主机的默认路由器称作源路由器，目的主机的默认路由器称作目的路由器。<br>一个分组从源主机到目的主机的路由选择问题即从源路由器到目的路由器的路由选择问题。<br><a id="more"></a><br>路由选择算法可分为：</p>
<ul>
<li>全局式路由选择算法：所有路由器掌握完整的网络拓扑和链路费用信息，例如链路状态（LS）路由算法</li>
<li>分散式路由选择算法：路由器只掌握物理相连的邻居以及链路费用，例如距离向量（DV）路由算法</li>
</ul>
<p>下面主要介绍链路状态路由算法（Link-stage）中的一种典型算法OSPF算法。</p>
<p>#一、OSPF是什么<br>Open Shortest Path First, 开放最短路径优先协议，是一种开源的使用最短路径优先（SPF）算法的内部网关协议（IGP）。常用于路由器的动态选路。</p>
<p>#二、OSPF常见的几个概念</p>
<ol>
<li>邻居（Neighbor）：宣告OSPF的路由器（也可能是通过quagga软件配置的普通服务器）从所有启动OSPF协议的接口上发出Hello数据包。如果两台路由器位于同一条数据链路上，并且它们根据互相的hello消息中指定的某些信息（比如id等）协商成功，那么它们就成为了邻居（Neighbor）。</li>
<li>邻接关系（Adjacency）：两台邻居路由器之间构成的一条点到点的虚链路，邻接关系的建立是由交换hello信息的路由器类型和网络类型决定的。</li>
<li>链路状态通告（Link State Advertisement，LSA）：每一台路由器都会在所有形成邻接关系的邻居之间发送链路状态通告LSA。LSA描述了路由器所有的链路、接口、邻居等信息。ospf定义了许多不同的LSA类型。</li>
<li>链路状态数据库（LSDB）：每一台收到来自邻居路由器发出的LSA的路由器都会把这些LSA信息记录在它的LSDB中，并且发送一份LSA的拷贝给该路由器的其他所有邻居。这样当LSA传播到整个区域后，区域内所有的路由器都会形成同样的LSDB。</li>
</ol>
<p>#三、OSPF的基本原理<br>OSPF算法是让每个路由器中的数据库储存整个网络的拓扑图，即每个路由器掌握了全局的信息，此时这个网络趋于稳定，便可以使用单源最短路径（Dijkstra）来选择路由。</p>
<p>每个路由器与其邻居的通信行为有以下几种：<br>1.保持联系<br>整个自治系统中，每个路由器都有唯一标识RouterID(32-bit). 与其每个邻居间隔30s，发送一次Hello 报文，意思就是你还活着吗？<br>二者相互通信发送Hello，并收到对方回应Hello。双方会周期性将自己的路由数据摘要发送给对方，一般30min，平时，<br>双方只是联系感情，直到对方没有挂。<br>2.告知现今情况<br><img src="https://upload-images.jianshu.io/upload_images/16845916-40717fbbfc3b07a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如图，R1会周期性地将自己的路由摘要发送给所有邻居。比如对R6路由器，R1会发送<br>称为DD报文的包，里面会说自己认识R6,R2,R4,R5,R6对比自己的信息库发现<br>除了自己R1的朋友它一个都不认识，于是就发送请求报文，请求告知这些不认识的<br>路由详情。这个请求报文称为LSR(链路状态请求报文)报文。<br>R1收到之后，直到R6还不认识自己另外三个朋友，于是发送LSU报文（链路状态更新）告知R6详情。R6收到之后，给R1个确认-LSAck报文。两个人现在认识的路由器一样多了，此时两个人是好基友了-全毗邻关系。</p>
<p>#四、Dijkstra算法<br>Dijkstra算法是典型的LS路由算法，可计算在网络中从一个节点到所有其他节点的最短路径。<br>之前在数据结构课上已经初步学习过这个算法，代码直接给出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;   </span><br><span class="line">#include&quot;stdlib.h&quot;   </span><br><span class="line">#define MAX 30000</span><br><span class="line">int n;</span><br><span class="line">int Arraya[100][100];       </span><br><span class="line"></span><br><span class="line">int BeginningPath()//说明初始化的路由连接信息</span><br><span class="line">&#123;          </span><br><span class="line">	int i,j,t;</span><br><span class="line">	printf(&quot;请输入节点的个数：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);//一共有n个节点</span><br><span class="line">	</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(j=i+1;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;从第%d个节点到第%d个节点的费用：&quot;,i,j);</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;t);	</span><br><span class="line">			if(t==-1) t=40000;	//-1表示 ∞</span><br><span class="line">			Arraya[j][i]=t;</span><br><span class="line">		    Arraya[i][j]=t;</span><br><span class="line">		&#125; </span><br><span class="line">		Arraya[i][i]=0;</span><br><span class="line">	&#125;</span><br><span class="line">    printf(&quot;\n\n在交换路由之前 : \n&quot;);</span><br><span class="line">	for(i=0;i&lt;n;i++)//显示初始化的数据</span><br><span class="line">	&#123;         </span><br><span class="line">			printf(&quot;\t&quot;);</span><br><span class="line">			for(j=0;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(Arraya[i][j]==40000)</span><br><span class="line">					printf(&quot;∞ &quot;);</span><br><span class="line">				else	</span><br><span class="line">					printf(&quot;%d  &quot;,Arraya[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Dijkstra(int s)	//求以s为源点到各点的最小路径及花费 </span><br><span class="line">&#123;</span><br><span class="line">	int flag[100],d[100]=&#123;0&#125;,next[100]=&#123;0&#125;;	//已知节点集合，距离矢量，下一跳 </span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=0;i&lt;n;i++)//初始化</span><br><span class="line">	&#123;</span><br><span class="line">		d[i]=Arraya[s][i];</span><br><span class="line">		flag[i]=0;</span><br><span class="line">		next[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	flag[s]=1;	//把源节点加入已知最短路径距离节点的集合 </span><br><span class="line">	int k=s,min;</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min=MAX;</span><br><span class="line">		for(j=0;j&lt;n;j++)//找出最小值d[k]</span><br><span class="line">			if(d[j]&lt;min&amp;&amp;flag[j]==0)</span><br><span class="line">			&#123;</span><br><span class="line">				min=d[j];	//寻找节点i的邻居中最近的节点，记录最小值及节点序号 </span><br><span class="line">				k=j;</span><br><span class="line">			&#125;</span><br><span class="line">		if(k==s)	return ;	//k值没有改变说明没有邻居 </span><br><span class="line">		flag[k]=1;//标志是否放入集合</span><br><span class="line">		for(j=0;j&lt;=n;j++)//松弛邻边（以新的已知集合构造新的与未知集合节点的距离） </span><br><span class="line">		    if(d[j]&gt;Arraya[k][j]+d[k]&amp;&amp;flag[j]==0)</span><br><span class="line">			&#123;</span><br><span class="line">				d[j]=Arraya[k][j]+d[k];</span><br><span class="line">				next[j]=next[k];	//到j节点的路径下一跳为中间点k，即到k的路径的下一跳 </span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;r%d  next  cost\n&quot;,s);</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(i==s)</span><br><span class="line">			continue;</span><br><span class="line">		printf(&quot;%d : %d  %d\n&quot;,i,next[i],d[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	BeginningPath();</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">		Dijkstra(i);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如我通过OSPF形成的网络拓扑图如下图，则可通过Dijkstra算法计算结果。<br><img src="https://upload-images.jianshu.io/upload_images/16845916-6c881b2ba82ecc74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>运行结果如图<br><img src="https://upload-images.jianshu.io/upload_images/16845916-fb22469440a5addd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/16845916-9336824df06cf17f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>参考链接：<br><a href="https://www.jianshu.com/p/332d866c41ed" target="_blank" rel="noopener">OSPF的基本原理</a><br><a href="https://blog.csdn.net/qq_33745102/article/details/82016413" target="_blank" rel="noopener">OSPF路由算法-Zoom in</a><br><a href="https://blog.csdn.net/qq_33361432/article/details/79464886" target="_blank" rel="noopener">LS链路状态路由算法</a><br><a href="https://blog.csdn.net/qq_22238021/article/details/80496138" target="_blank" rel="noopener">路由选择算法 LS DV</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Zepeng Wang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/05/10/链路状态路由选择算法LS/">http://yoursite.com/2019/05/10/链路状态路由选择算法LS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">王小鹏's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/路由算法/">路由算法</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/01/29/肺炎之下/"><i class="fa fa-chevron-left">  </i><span>肺炎之下</span></a></div><div class="next-post pull-right"><a href="/2019/03/08/一次疑似主机被DNS污染的记录/"><span>一次疑似主机被DNS污染的记录</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Zepeng Wang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body></html>